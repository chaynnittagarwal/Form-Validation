import { ChangeDetectionStrategy, ChangeDetectorRef, Component, ContentChildren, Directive, ElementRef, Inject, Input, Optional, TemplateRef, ViewChild, ViewContainerRef, ViewEncapsulation, InjectionToken, } from '@angular/core';
import { MatFormField, } from '@angular/material/form-field';
import { distinctUntilChanged, map, startWith } from 'rxjs/operators';
import { DEFAULT_ERROR_MESSAGES } from './error-meassages';
import { getNgxMatErrorDefMissingForError } from './errors';
export const NGX_MAT_ERROR_DEFAULT_OPTIONS = new InjectionToken('NGX_MAT_ERROR_DEFAULT_OPTIONS');
export class NgxMatErrorDef {
    constructor(template) {
        this.template = template;
    }
    ngOnInit() {
        if (!this.ngxMatErrorDefFor) {
            throw getNgxMatErrorDefMissingForError();
        }
    }
}
NgxMatErrorDef.decorators = [
    { type: Directive, args: [{
                selector: '[ngxMatErrorDef]',
            },] }
];
NgxMatErrorDef.ctorParameters = () => [
    { type: TemplateRef }
];
NgxMatErrorDef.propDecorators = {
    ngxMatErrorDefFor: [{ type: Input }]
};
export class NgxMatErrorOutlet {
    constructor(viewContainer, elementRef) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
    }
}
NgxMatErrorOutlet.decorators = [
    { type: Directive, args: [{ selector: '[ngxMatErrorOutlet]' },] }
];
NgxMatErrorOutlet.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef }
];
export class NgxMatErrors {
    constructor(cdRef, messages, matFormField) {
        this.cdRef = cdRef;
        this.matFormField = matFormField;
        this.messages = messages || DEFAULT_ERROR_MESSAGES;
        this.messageKeys = new Set(Object.keys(this.messages));
    }
    ngOnInit() {
        if (!this.control && this.matFormField) {
            this.control = this.matFormField._control;
        }
        if (this.control) {
            const control = this.control.ngControl;
            const stateChanges = this.control.stateChanges;
            if (control && stateChanges) {
                this.initError(control, stateChanges);
            }
        }
    }
    initError(control, stateChanges) {
        this.error$ = stateChanges.pipe(startWith(null), map(() => {
            if (!control.errors) {
                return;
            }
            const errorKeys = Object.keys(control.errors);
            const customErrorMessage = this._getCustomErrorMessage(errorKeys);
            if (customErrorMessage) {
                return customErrorMessage;
            }
            return errorKeys.find((key) => this.messageKeys.has(key));
        }), distinctUntilChanged(), map((errorOrErrorDef) => {
            this.errorOutlet.viewContainer.clear();
            if (!errorOrErrorDef) {
                return '';
            }
            const errors = control.errors;
            if (errorOrErrorDef instanceof NgxMatErrorDef) {
                this._populateErrorOutlet(errorOrErrorDef, errors);
                return '';
            }
            const message = this.messages[errorOrErrorDef];
            if (typeof message === 'function') {
                return message(errors[errorOrErrorDef]);
            }
            return message;
        }), distinctUntilChanged());
    }
    _populateErrorOutlet(errorDef, errors) {
        const context = {
            $implicit: errors[errorDef.ngxMatErrorDefFor],
        };
        this.errorOutlet.viewContainer.createEmbeddedView(errorDef.template, context);
        this.cdRef.markForCheck();
    }
    _getCustomErrorMessage(errors) {
        return this.customErrorMessages.find((customErrorMessage) => errors.some((error) => error === customErrorMessage.ngxMatErrorDefFor));
    }
}
NgxMatErrors.decorators = [
    { type: Component, args: [{
                selector: 'ngx-mat-errors, [ngx-mat-errors]',
                template: `
    {{ error$ | async }}
    <ng-container ngxMatErrorOutlet></ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'ngx-mat-errors',
                }
            },] }
];
NgxMatErrors.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NGX_MAT_ERROR_DEFAULT_OPTIONS,] }] },
    { type: MatFormField, decorators: [{ type: Optional }] }
];
NgxMatErrors.propDecorators = {
    errorOutlet: [{ type: ViewChild, args: [NgxMatErrorOutlet, { static: true },] }],
    customErrorMessages: [{ type: ContentChildren, args: [NgxMatErrorDef, { descendants: true },] }],
    control: [{ type: Input, args: ['ngx-mat-errors',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmd4LW1hdC1lcnJvcnMuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6IkM6L1JlcG9zL25neC1tYXQtZXJyb3JzL3Byb2plY3RzL25neC1tYXQtZXJyb3JzL3NyYy8iLCJzb3VyY2VzIjpbImxpYi9uZ3gtbWF0LWVycm9ycy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUNMLHVCQUF1QixFQUN2QixpQkFBaUIsRUFDakIsU0FBUyxFQUNULGVBQWUsRUFDZixTQUFTLEVBQ1QsVUFBVSxFQUNWLE1BQU0sRUFDTixLQUFLLEVBRUwsUUFBUSxFQUVSLFdBQVcsRUFDWCxTQUFTLEVBQ1QsZ0JBQWdCLEVBQ2hCLGlCQUFpQixFQUNqQixjQUFjLEdBQ2YsTUFBTSxlQUFlLENBQUM7QUFFdkIsT0FBTyxFQUNMLFlBQVksR0FFYixNQUFNLDhCQUE4QixDQUFDO0FBRXRDLE9BQU8sRUFBRSxvQkFBb0IsRUFBRSxHQUFHLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7QUFDdEUsT0FBTyxFQUFFLHNCQUFzQixFQUFpQixNQUFNLG1CQUFtQixDQUFDO0FBQzFFLE9BQU8sRUFBRSxnQ0FBZ0MsRUFBRSxNQUFNLFVBQVUsQ0FBQztBQUU1RCxNQUFNLENBQUMsTUFBTSw2QkFBNkIsR0FBRyxJQUFJLGNBQWMsQ0FDN0QsK0JBQStCLENBQ2hDLENBQUM7QUFTRixNQUFNLE9BQU8sY0FBYztJQUV6QixZQUFtQixRQUEwQjtRQUExQixhQUFRLEdBQVIsUUFBUSxDQUFrQjtJQUFHLENBQUM7SUFFakQsUUFBUTtRQUNOLElBQUcsQ0FBQyxJQUFJLENBQUMsaUJBQWlCLEVBQUM7WUFDekIsTUFBTSxnQ0FBZ0MsRUFBRSxDQUFDO1NBQzFDO0lBQ0gsQ0FBQzs7O1lBWEYsU0FBUyxTQUFDO2dCQUNULFFBQVEsRUFBRSxrQkFBa0I7YUFDN0I7OztZQTFCQyxXQUFXOzs7Z0NBNEJWLEtBQUs7O0FBV1IsTUFBTSxPQUFPLGlCQUFpQjtJQUM1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ZURldGVjdG9yUmVmLFxuICBDb21wb25lbnQsXG4gIENvbnRlbnRDaGlsZHJlbixcbiAgRGlyZWN0aXZlLFxuICBFbGVtZW50UmVmLFxuICBJbmplY3QsXG4gIElucHV0LFxuICBPbkluaXQsXG4gIE9wdGlvbmFsLFxuICBRdWVyeUxpc3QsXG4gIFRlbXBsYXRlUmVmLFxuICBWaWV3Q2hpbGQsXG4gIFZpZXdDb250YWluZXJSZWYsXG4gIFZpZXdFbmNhcHN1bGF0aW9uLFxuICBJbmplY3Rpb25Ub2tlbixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBOZ0NvbnRyb2wsIFZhbGlkYXRpb25FcnJvcnMgfSBmcm9tICdAYW5ndWxhci9mb3Jtcyc7XG5pbXBvcnQge1xuICBNYXRGb3JtRmllbGQsXG4gIE1hdEZvcm1GaWVsZENvbnRyb2wsXG59IGZyb20gJ0Bhbmd1bGFyL21hdGVyaWFsL2Zvcm0tZmllbGQnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgZGlzdGluY3RVbnRpbENoYW5nZWQsIG1hcCwgc3RhcnRXaXRoIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgREVGQVVMVF9FUlJPUl9NRVNTQUdFUywgRXJyb3JNZXNzYWdlcyB9IGZyb20gJy4vZXJyb3ItbWVhc3NhZ2VzJztcbmltcG9ydCB7IGdldE5neE1hdEVycm9yRGVmTWlzc2luZ0ZvckVycm9yIH0gZnJvbSAnLi9lcnJvcnMnO1xuXG5leHBvcnQgY29uc3QgTkdYX01BVF9FUlJPUl9ERUZBVUxUX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48RXJyb3JNZXNzYWdlcz4oXG4gICdOR1hfTUFUX0VSUk9SX0RFRkFVTFRfT1BUSU9OUydcbik7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRXJyb3JPdXRsZXRDb250ZXh0PFQ+IHtcbiAgJGltcGxpY2l0PzogVDtcbn1cblxuQERpcmVjdGl2ZSh7XG4gIHNlbGVjdG9yOiAnW25neE1hdEVycm9yRGVmXScsXG59KVxuZXhwb3J0IGNsYXNzIE5neE1hdEVycm9yRGVmIGltcGxlbWVudHMgT25Jbml0e1xuICBASW5wdXQoKSBuZ3hNYXRFcnJvckRlZkZvciE6IHN0cmluZztcbiAgY29uc3RydWN0b3IocHVibGljIHRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+KSB7fVxuXG4gIG5nT25Jbml0KCl7XG4gICAgaWYoIXRoaXMubmd4TWF0RXJyb3JEZWZGb3Ipe1xuICAgICAgdGhyb3cgZ2V0Tmd4TWF0RXJyb3JEZWZNaXNzaW5nRm9yRXJyb3IoKTtcbiAgICB9XG4gIH1cbn1cblxuQERpcmVjdGl2ZSh7IHNlbGVjdG9yOiAnW25neE1hdEVycm9yT3V0bGV0XScgfSlcbmV4cG9ydCBjbGFzcyBOZ3hNYXRFcnJvck91dGxldCB7XG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyByZWFkb25seSB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHB1YmxpYyByZWFkb25seSBlbGVtZW50UmVmOiBFbGVtZW50UmVmXG4gICkge31cbn1cblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnbmd4LW1hdC1lcnJvcnMsIFtuZ3gtbWF0LWVycm9yc10nLFxuICB0ZW1wbGF0ZTogYFxuICAgIHt7IGVycm9yJCB8IGFzeW5jIH19XG4gICAgPG5nLWNvbnRhaW5lciBuZ3hNYXRFcnJvck91dGxldD48L25nLWNvbnRhaW5lcj5cbiAgYCxcbiAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gIGhvc3Q6IHtcbiAgICBjbGFzczogJ25neC1tYXQtZXJyb3JzJyxcbiAgfSxcbn0pXG5leHBvcnQgY2xhc3MgTmd4TWF0RXJyb3JzPFQ+IGltcGxlbWVudHMgT25Jbml0IHtcbiAgcHJpdmF0ZSByZWFkb25seSBtZXNzYWdlczogRXJyb3JNZXNzYWdlcztcbiAgcHJpdmF0ZSByZWFkb25seSBtZXNzYWdlS2V5czogU2V0PHN0cmluZz47XG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY2RSZWY6IENoYW5nZURldGVjdG9yUmVmLFxuICAgIEBPcHRpb25hbCgpXG4gICAgQEluamVjdChOR1hfTUFUX0VSUk9SX0RFRkFVTFRfT1BUSU9OUylcbiAgICBtZXNzYWdlczogRXJyb3JNZXNzYWdlcyB8IG51bGwsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSByZWFkb25seSBtYXRGb3JtRmllbGQ6IE1hdEZvcm1GaWVsZFxuICApIHtcbiAgICB0aGlzLm1lc3NhZ2VzID0gbWVzc2FnZXMgfHwgREVGQVVMVF9FUlJPUl9NRVNTQUdFUztcbiAgICB0aGlzLm1lc3NhZ2VLZXlzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLm1lc3NhZ2VzKSk7XG4gIH1cblxuICBAVmlld0NoaWxkKE5neE1hdEVycm9yT3V0bGV0LCB7IHN0YXRpYzogdHJ1ZSB9KVxuICByZWFkb25seSBlcnJvck91dGxldCE6IE5neE1hdEVycm9yT3V0bGV0O1xuXG4gIEBDb250ZW50Q2hpbGRyZW4oTmd4TWF0RXJyb3JEZWYsIHsgZGVzY2VuZGFudHM6IHRydWUgfSlcbiAgcmVhZG9ubHkgY3VzdG9tRXJyb3JNZXNzYWdlcyE6IFF1ZXJ5TGlzdDxOZ3hNYXRFcnJvckRlZj47XG5cbiAgcmVhZG9ubHkgZXJyb3IkITogT2JzZXJ2YWJsZTxzdHJpbmc+O1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogbm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dCgnbmd4LW1hdC1lcnJvcnMnKVxuICBjb250cm9sPzogTWF0Rm9ybUZpZWxkQ29udHJvbDxhbnk+IHwgXCJcIiB8IG51bGw7XG5cbiAgbmdPbkluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRyb2wgJiYgdGhpcy5tYXRGb3JtRmllbGQpIHtcbiAgICAgIHRoaXMuY29udHJvbCA9IHRoaXMubWF0Rm9ybUZpZWxkLl9jb250cm9sO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb250cm9sKSB7XG4gICAgICBjb25zdCBjb250cm9sID0gdGhpcy5jb250cm9sLm5nQ29udHJvbDtcbiAgICAgIGNvbnN0IHN0YXRlQ2hhbmdlcyA9IHRoaXMuY29udHJvbC5zdGF0ZUNoYW5nZXM7XG4gICAgICBpZiAoY29udHJvbCAmJiBzdGF0ZUNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5pbml0RXJyb3IoY29udHJvbCwgc3RhdGVDaGFuZ2VzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGluaXRFcnJvcihjb250cm9sOiBOZ0NvbnRyb2wsIHN0YXRlQ2hhbmdlczogT2JzZXJ2YWJsZTxhbnk+KSB7XG4gICAgKHRoaXMgYXMgYW55KS5lcnJvciQgPSBzdGF0ZUNoYW5nZXMucGlwZShcbiAgICAgIHN0YXJ0V2l0aChudWxsIGFzIGFueSksXG4gICAgICBtYXAoKCkgPT4ge1xuICAgICAgICBpZiAoIWNvbnRyb2wuZXJyb3JzKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVycm9yS2V5cyA9IE9iamVjdC5rZXlzKGNvbnRyb2wuZXJyb3JzKTtcbiAgICAgICAgY29uc3QgY3VzdG9tRXJyb3JNZXNzYWdlID0gdGhpcy5fZ2V0Q3VzdG9tRXJyb3JNZXNzYWdlKGVycm9yS2V5cyk7XG4gICAgICAgIGlmIChjdXN0b21FcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gY3VzdG9tRXJyb3JNZXNzYWdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcktleXMuZmluZCgoa2V5KSA9PiB0aGlzLm1lc3NhZ2VLZXlzLmhhcyhrZXkpKTtcbiAgICAgIH0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKSxcbiAgICAgIG1hcCgoZXJyb3JPckVycm9yRGVmOiB1bmRlZmluZWQgfCBOZ3hNYXRFcnJvckRlZiB8IHN0cmluZykgPT4ge1xuICAgICAgICB0aGlzLmVycm9yT3V0bGV0LnZpZXdDb250YWluZXIuY2xlYXIoKTtcbiAgICAgICAgaWYgKCFlcnJvck9yRXJyb3JEZWYpIHtcbiAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJyb3JzID0gY29udHJvbC5lcnJvcnMgYXMgVmFsaWRhdGlvbkVycm9ycztcbiAgICAgICAgaWYgKGVycm9yT3JFcnJvckRlZiBpbnN0YW5jZW9mIE5neE1hdEVycm9yRGVmKSB7XG4gICAgICAgICAgdGhpcy5fcG9wdWxhdGVFcnJvck91dGxldChlcnJvck9yRXJyb3JEZWYsIGVycm9ycyk7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB0aGlzLm1lc3NhZ2VzW2Vycm9yT3JFcnJvckRlZl07XG4gICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgIHJldHVybiBtZXNzYWdlKGVycm9yc1tlcnJvck9yRXJyb3JEZWZdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICAgIH0pLFxuICAgICAgZGlzdGluY3RVbnRpbENoYW5nZWQoKVxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIF9wb3B1bGF0ZUVycm9yT3V0bGV0KFxuICAgIGVycm9yRGVmOiBOZ3hNYXRFcnJvckRlZixcbiAgICBlcnJvcnM6IFZhbGlkYXRpb25FcnJvcnNcbiAgKSB7XG4gICAgY29uc3QgY29udGV4dDogRXJyb3JPdXRsZXRDb250ZXh0PFQ+ID0ge1xuICAgICAgJGltcGxpY2l0OiBlcnJvcnNbZXJyb3JEZWYubmd4TWF0RXJyb3JEZWZGb3JdLFxuICAgIH07XG4gICAgdGhpcy5lcnJvck91dGxldC52aWV3Q29udGFpbmVyLmNyZWF0ZUVtYmVkZGVkVmlldyhcbiAgICAgIGVycm9yRGVmLnRlbXBsYXRlLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gICAgdGhpcy5jZFJlZi5tYXJrRm9yQ2hlY2soKTtcbiAgfVxuXG4gIHByaXZhdGUgX2dldEN1c3RvbUVycm9yTWVzc2FnZShlcnJvcnM6IHN0cmluZ1tdKSB7XG4gICAgcmV0dXJuIHRoaXMuY3VzdG9tRXJyb3JNZXNzYWdlcy5maW5kKChjdXN0b21FcnJvck1lc3NhZ2UpID0+XG4gICAgICBlcnJvcnMuc29tZSgoZXJyb3IpID0+IGVycm9yID09PSBjdXN0b21FcnJvck1lc3NhZ2Uubmd4TWF0RXJyb3JEZWZGb3IpXG4gICAgKTtcbiAgfVxufVxuIl19