import { InjectionToken, Directive, TemplateRef, Input, ViewContainerRef, ElementRef, Component, ViewEncapsulation, ChangeDetectionStrategy, ChangeDetectorRef, Optional, Inject, ViewChild, ContentChildren, NgModule, LOCALE_ID } from '@angular/core';
import { MatFormField } from '@angular/material/form-field';
import { startWith, map, distinctUntilChanged } from 'rxjs/operators';
import { CommonModule, formatDate } from '@angular/common';

const ɵ0 = (error) => `Please enter a value greater than or equal to ${error.min}.`, ɵ1 = (error) => `Please enter a value less than or equal to ${error.max}.`, ɵ2 = (error) => `Please enter at least ${error.requiredLength} characters.`, ɵ3 = (error) => `Please enter no more than ${error.requiredLength} characters.`, ɵ4 = (error) => `Please enter a date greater than or equal to ${error.min}.`, ɵ5 = (error) => `Please enter a date less than or equal to ${error.max}.`;
const DEFAULT_ERROR_MESSAGES = {
    min: ɵ0,
    max: ɵ1,
    required: `This field is required.`,
    email: `Please enter a valid email address.`,
    minlength: ɵ2,
    maxlength: ɵ3,
    matDatepickerMin: ɵ4,
    matDatepickerMax: ɵ5,
};

/** @docs-private */
function getNgxMatErrorDefMissingForError() {
    return Error(`'for' must be set for ngxMatErrorDef. See example: *ngxMatErrorDef="let error; for: 'pattern'`);
}

const NGX_MAT_ERROR_DEFAULT_OPTIONS = new InjectionToken('NGX_MAT_ERROR_DEFAULT_OPTIONS');
class NgxMatErrorDef {
    constructor(template) {
        this.template = template;
    }
    ngOnInit() {
        if (!this.ngxMatErrorDefFor) {
            throw getNgxMatErrorDefMissingForError();
        }
    }
}
NgxMatErrorDef.decorators = [
    { type: Directive, args: [{
                selector: '[ngxMatErrorDef]',
            },] }
];
NgxMatErrorDef.ctorParameters = () => [
    { type: TemplateRef }
];
NgxMatErrorDef.propDecorators = {
    ngxMatErrorDefFor: [{ type: Input }]
};
class NgxMatErrorOutlet {
    constructor(viewContainer, elementRef) {
        this.viewContainer = viewContainer;
        this.elementRef = elementRef;
    }
}
NgxMatErrorOutlet.decorators = [
    { type: Directive, args: [{ selector: '[ngxMatErrorOutlet]' },] }
];
NgxMatErrorOutlet.ctorParameters = () => [
    { type: ViewContainerRef },
    { type: ElementRef }
];
class NgxMatErrors {
    constructor(cdRef, messages, matFormField) {
        this.cdRef = cdRef;
        this.matFormField = matFormField;
        this.messages = messages || DEFAULT_ERROR_MESSAGES;
        this.messageKeys = new Set(Object.keys(this.messages));
    }
    ngOnInit() {
        if (!this.control && this.matFormField) {
            this.control = this.matFormField._control;
        }
        if (this.control) {
            const control = this.control.ngControl;
            const stateChanges = this.control.stateChanges;
            if (control && stateChanges) {
                this.initError(control, stateChanges);
            }
        }
    }
    initError(control, stateChanges) {
        this.error$ = stateChanges.pipe(startWith(null), map(() => {
            if (!control.errors) {
                return;
            }
            const errorKeys = Object.keys(control.errors);
            const customErrorMessage = this._getCustomErrorMessage(errorKeys);
            if (customErrorMessage) {
                return customErrorMessage;
            }
            return errorKeys.find((key) => this.messageKeys.has(key));
        }), distinctUntilChanged(), map((errorOrErrorDef) => {
            this.errorOutlet.viewContainer.clear();
            if (!errorOrErrorDef) {
                return '';
            }
            const errors = control.errors;
            if (errorOrErrorDef instanceof NgxMatErrorDef) {
                this._populateErrorOutlet(errorOrErrorDef, errors);
                return '';
            }
            const message = this.messages[errorOrErrorDef];
            if (typeof message === 'function') {
                return message(errors[errorOrErrorDef]);
            }
            return message;
        }), distinctUntilChanged());
    }
    _populateErrorOutlet(errorDef, errors) {
        const context = {
            $implicit: errors[errorDef.ngxMatErrorDefFor],
        };
        this.errorOutlet.viewContainer.createEmbeddedView(errorDef.template, context);
        this.cdRef.markForCheck();
    }
    _getCustomErrorMessage(errors) {
        return this.customErrorMessages.find((customErrorMessage) => errors.some((error) => error === customErrorMessage.ngxMatErrorDefFor));
    }
}
NgxMatErrors.decorators = [
    { type: Component, args: [{
                selector: 'ngx-mat-errors, [ngx-mat-errors]',
                template: `
    {{ error$ | async }}
    <ng-container ngxMatErrorOutlet></ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: {
                    class: 'ngx-mat-errors',
                }
            },] }
];
NgxMatErrors.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NGX_MAT_ERROR_DEFAULT_OPTIONS,] }] },
    { type: MatFormField, decorators: [{ type: Optional }] }
];
NgxMatErrors.propDecorators = {
    errorOutlet: [{ type: ViewChild, args: [NgxMatErrorOutlet, { static: true },] }],
    customErrorMessages: [{ type: ContentChildren, args: [NgxMatErrorDef, { descendants: true },] }],
    control: [{ type: Input, args: ['ngx-mat-errors',] }]
};

class NgxMatErrorsModule {
}
NgxMatErrorsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgxMatErrors, NgxMatErrorDef, NgxMatErrorOutlet],
                imports: [CommonModule],
                exports: [NgxMatErrors, NgxMatErrorDef],
            },] }
];

function errorMessagesEnFactory(locale, format = 'shortDate') {
    return {
        min: (error) => `Please enter a value greater than or equal to ${error.min}.`,
        max: (error) => `Please enter a value less than or equal to ${error.max}.`,
        required: `This field is required.`,
        email: `Please enter a valid email address.`,
        minlength: (error) => `Please enter at least ${error.requiredLength} characters.`,
        maxlength: (error) => `Please enter no more than ${error.requiredLength} characters.`,
        matDatepickerMin: (error) => {
            const formatted = formatDate(error.min, format, locale);
            return `Please enter a date greater than or equal to ${formatted !== null && formatted !== void 0 ? formatted : error.min}.`;
        },
        matDatepickerMax: (error) => {
            const formatted = formatDate(error.max, format, locale);
            return `Please enter a date less than or equal to ${formatted !== null && formatted !== void 0 ? formatted : error.max}.`;
        },
    };
}
const NGX_MAT_ERROR_CONFIG_EN = {
    provide: NGX_MAT_ERROR_DEFAULT_OPTIONS,
    useFactory: errorMessagesEnFactory,
    deps: [LOCALE_ID],
};

function errorMessagesHuFactory(locale, format = 'shortDate') {
    return {
        min: (error) => `Nem lehet kisebb, mint ${error.min}.`,
        max: (error) => `Nem lehet nagyobb, mint ${error.max}.`,
        required: `Kötelező mező.`,
        email: `Nem érvényes e-mail cím.`,
        minlength: (error) => `Legalább ${error.requiredLength} karakter hosszú lehet.`,
        maxlength: (error) => `Legfeljebb ${error.requiredLength} karakter hosszú lehet.`,
        server: (error) => error,
        matDatepickerMin: (error) => {
            const formatted = formatDate(error.min, format, locale);
            return `Nem lehet korábbi dátum, mint ${formatted !== null && formatted !== void 0 ? formatted : error.min}`;
        },
        matDatepickerMax: (error) => {
            const formatted = formatDate(error.max, format, locale);
            return `Nem lehet készőbbi dátum, mint ${formatted !== null && formatted !== void 0 ? formatted : error.max}`;
        },
    };
}
const NGX_MAT_ERROR_CONFIG_HU = {
    provide: NGX_MAT_ERROR_DEFAULT_OPTIONS,
    useFactory: errorMessagesHuFactory,
    deps: [LOCALE_ID]
};

/*
 * Public API Surface of ngx-mat-errors
 */

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_ERROR_MESSAGES, NGX_MAT_ERROR_CONFIG_EN, NGX_MAT_ERROR_CONFIG_HU, NGX_MAT_ERROR_DEFAULT_OPTIONS, NgxMatErrorDef, NgxMatErrorOutlet, NgxMatErrors, NgxMatErrorsModule, errorMessagesEnFactory, errorMessagesHuFactory, ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5 };
//# sourceMappingURL=ngx-mat-errors.js.map
