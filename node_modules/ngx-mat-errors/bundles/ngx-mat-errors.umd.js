(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/material/form-field'), require('rxjs/operators'), require('@angular/common')) :
    typeof define === 'function' && define.amd ? define('ngx-mat-errors', ['exports', '@angular/core', '@angular/material/form-field', 'rxjs/operators', '@angular/common'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-mat-errors'] = {}, global.ng.core, global.ng.material.formField, global.rxjs.operators, global.ng.common));
}(this, (function (exports, core, formField, operators, common) { 'use strict';

    var ɵ0 = function (error) { return "Please enter a value greater than or equal to " + error.min + "."; }, ɵ1 = function (error) { return "Please enter a value less than or equal to " + error.max + "."; }, ɵ2 = function (error) { return "Please enter at least " + error.requiredLength + " characters."; }, ɵ3 = function (error) { return "Please enter no more than " + error.requiredLength + " characters."; }, ɵ4 = function (error) { return "Please enter a date greater than or equal to " + error.min + "."; }, ɵ5 = function (error) { return "Please enter a date less than or equal to " + error.max + "."; };
    var DEFAULT_ERROR_MESSAGES = {
        min: ɵ0,
        max: ɵ1,
        required: "This field is required.",
        email: "Please enter a valid email address.",
        minlength: ɵ2,
        maxlength: ɵ3,
        matDatepickerMin: ɵ4,
        matDatepickerMax: ɵ5,
    };

    /** @docs-private */
    function getNgxMatErrorDefMissingForError() {
        return Error("'for' must be set for ngxMatErrorDef. See example: *ngxMatErrorDef=\"let error; for: 'pattern'");
    }

    var NGX_MAT_ERROR_DEFAULT_OPTIONS = new core.InjectionToken('NGX_MAT_ERROR_DEFAULT_OPTIONS');
    var NgxMatErrorDef = /** @class */ (function () {
        function NgxMatErrorDef(template) {
            this.template = template;
        }
        NgxMatErrorDef.prototype.ngOnInit = function () {
            if (!this.ngxMatErrorDefFor) {
                throw getNgxMatErrorDefMissingForError();
            }
        };
        return NgxMatErrorDef;
    }());
    NgxMatErrorDef.decorators = [
        { type: core.Directive, args: [{
                    selector: '[ngxMatErrorDef]',
                },] }
    ];
    NgxMatErrorDef.ctorParameters = function () { return [
        { type: core.TemplateRef }
    ]; };
    NgxMatErrorDef.propDecorators = {
        ngxMatErrorDefFor: [{ type: core.Input }]
    };
    var NgxMatErrorOutlet = /** @class */ (function () {
        function NgxMatErrorOutlet(viewContainer, elementRef) {
            this.viewContainer = viewContainer;
            this.elementRef = elementRef;
        }
        return NgxMatErrorOutlet;
    }());
    NgxMatErrorOutlet.decorators = [
        { type: core.Directive, args: [{ selector: '[ngxMatErrorOutlet]' },] }
    ];
    NgxMatErrorOutlet.ctorParameters = function () { return [
        { type: core.ViewContainerRef },
        { type: core.ElementRef }
    ]; };
    var NgxMatErrors = /** @class */ (function () {
        function NgxMatErrors(cdRef, messages, matFormField) {
            this.cdRef = cdRef;
            this.matFormField = matFormField;
            this.messages = messages || DEFAULT_ERROR_MESSAGES;
            this.messageKeys = new Set(Object.keys(this.messages));
        }
        NgxMatErrors.prototype.ngOnInit = function () {
            if (!this.control && this.matFormField) {
                this.control = this.matFormField._control;
            }
            if (this.control) {
                var control = this.control.ngControl;
                var stateChanges = this.control.stateChanges;
                if (control && stateChanges) {
                    this.initError(control, stateChanges);
                }
            }
        };
        NgxMatErrors.prototype.initError = function (control, stateChanges) {
            var _this = this;
            this.error$ = stateChanges.pipe(operators.startWith(null), operators.map(function () {
                if (!control.errors) {
                    return;
                }
                var errorKeys = Object.keys(control.errors);
                var customErrorMessage = _this._getCustomErrorMessage(errorKeys);
                if (customErrorMessage) {
                    return customErrorMessage;
                }
                return errorKeys.find(function (key) { return _this.messageKeys.has(key); });
            }), operators.distinctUntilChanged(), operators.map(function (errorOrErrorDef) {
                _this.errorOutlet.viewContainer.clear();
                if (!errorOrErrorDef) {
                    return '';
                }
                var errors = control.errors;
                if (errorOrErrorDef instanceof NgxMatErrorDef) {
                    _this._populateErrorOutlet(errorOrErrorDef, errors);
                    return '';
                }
                var message = _this.messages[errorOrErrorDef];
                if (typeof message === 'function') {
                    return message(errors[errorOrErrorDef]);
                }
                return message;
            }), operators.distinctUntilChanged());
        };
        NgxMatErrors.prototype._populateErrorOutlet = function (errorDef, errors) {
            var context = {
                $implicit: errors[errorDef.ngxMatErrorDefFor],
            };
            this.errorOutlet.viewContainer.createEmbeddedView(errorDef.template, context);
            this.cdRef.markForCheck();
        };
        NgxMatErrors.prototype._getCustomErrorMessage = function (errors) {
            return this.customErrorMessages.find(function (customErrorMessage) { return errors.some(function (error) { return error === customErrorMessage.ngxMatErrorDefFor; }); });
        };
        return NgxMatErrors;
    }());
    NgxMatErrors.decorators = [
        { type: core.Component, args: [{
                    selector: 'ngx-mat-errors, [ngx-mat-errors]',
                    template: "\n    {{ error$ | async }}\n    <ng-container ngxMatErrorOutlet></ng-container>\n  ",
                    encapsulation: core.ViewEncapsulation.None,
                    changeDetection: core.ChangeDetectionStrategy.OnPush,
                    host: {
                        class: 'ngx-mat-errors',
                    }
                },] }
    ];
    NgxMatErrors.ctorParameters = function () { return [
        { type: core.ChangeDetectorRef },
        { type: undefined, decorators: [{ type: core.Optional }, { type: core.Inject, args: [NGX_MAT_ERROR_DEFAULT_OPTIONS,] }] },
        { type: formField.MatFormField, decorators: [{ type: core.Optional }] }
    ]; };
    NgxMatErrors.propDecorators = {
        errorOutlet: [{ type: core.ViewChild, args: [NgxMatErrorOutlet, { static: true },] }],
        customErrorMessages: [{ type: core.ContentChildren, args: [NgxMatErrorDef, { descendants: true },] }],
        control: [{ type: core.Input, args: ['ngx-mat-errors',] }]
    };

    var NgxMatErrorsModule = /** @class */ (function () {
        function NgxMatErrorsModule() {
        }
        return NgxMatErrorsModule;
    }());
    NgxMatErrorsModule.decorators = [
        { type: core.NgModule, args: [{
                    declarations: [NgxMatErrors, NgxMatErrorDef, NgxMatErrorOutlet],
                    imports: [common.CommonModule],
                    exports: [NgxMatErrors, NgxMatErrorDef],
                },] }
    ];

    function errorMessagesEnFactory(locale, format) {
        if (format === void 0) { format = 'shortDate'; }
        return {
            min: function (error) { return "Please enter a value greater than or equal to " + error.min + "."; },
            max: function (error) { return "Please enter a value less than or equal to " + error.max + "."; },
            required: "This field is required.",
            email: "Please enter a valid email address.",
            minlength: function (error) { return "Please enter at least " + error.requiredLength + " characters."; },
            maxlength: function (error) { return "Please enter no more than " + error.requiredLength + " characters."; },
            matDatepickerMin: function (error) {
                var formatted = common.formatDate(error.min, format, locale);
                return "Please enter a date greater than or equal to " + (formatted !== null && formatted !== void 0 ? formatted : error.min) + ".";
            },
            matDatepickerMax: function (error) {
                var formatted = common.formatDate(error.max, format, locale);
                return "Please enter a date less than or equal to " + (formatted !== null && formatted !== void 0 ? formatted : error.max) + ".";
            },
        };
    }
    var NGX_MAT_ERROR_CONFIG_EN = {
        provide: NGX_MAT_ERROR_DEFAULT_OPTIONS,
        useFactory: errorMessagesEnFactory,
        deps: [core.LOCALE_ID],
    };

    function errorMessagesHuFactory(locale, format) {
        if (format === void 0) { format = 'shortDate'; }
        return {
            min: function (error) { return "Nem lehet kisebb, mint " + error.min + "."; },
            max: function (error) { return "Nem lehet nagyobb, mint " + error.max + "."; },
            required: "K\u00F6telez\u0151 mez\u0151.",
            email: "Nem \u00E9rv\u00E9nyes e-mail c\u00EDm.",
            minlength: function (error) { return "Legal\u00E1bb " + error.requiredLength + " karakter hossz\u00FA lehet."; },
            maxlength: function (error) { return "Legfeljebb " + error.requiredLength + " karakter hossz\u00FA lehet."; },
            server: function (error) { return error; },
            matDatepickerMin: function (error) {
                var formatted = common.formatDate(error.min, format, locale);
                return "Nem lehet kor\u00E1bbi d\u00E1tum, mint " + (formatted !== null && formatted !== void 0 ? formatted : error.min);
            },
            matDatepickerMax: function (error) {
                var formatted = common.formatDate(error.max, format, locale);
                return "Nem lehet k\u00E9sz\u0151bbi d\u00E1tum, mint " + (formatted !== null && formatted !== void 0 ? formatted : error.max);
            },
        };
    }
    var NGX_MAT_ERROR_CONFIG_HU = {
        provide: NGX_MAT_ERROR_DEFAULT_OPTIONS,
        useFactory: errorMessagesHuFactory,
        deps: [core.LOCALE_ID]
    };

    /*
     * Public API Surface of ngx-mat-errors
     */

    /**
     * Generated bundle index. Do not edit.
     */

    exports.DEFAULT_ERROR_MESSAGES = DEFAULT_ERROR_MESSAGES;
    exports.NGX_MAT_ERROR_CONFIG_EN = NGX_MAT_ERROR_CONFIG_EN;
    exports.NGX_MAT_ERROR_CONFIG_HU = NGX_MAT_ERROR_CONFIG_HU;
    exports.NGX_MAT_ERROR_DEFAULT_OPTIONS = NGX_MAT_ERROR_DEFAULT_OPTIONS;
    exports.NgxMatErrorDef = NgxMatErrorDef;
    exports.NgxMatErrorOutlet = NgxMatErrorOutlet;
    exports.NgxMatErrors = NgxMatErrors;
    exports.NgxMatErrorsModule = NgxMatErrorsModule;
    exports.errorMessagesEnFactory = errorMessagesEnFactory;
    exports.errorMessagesHuFactory = errorMessagesHuFactory;
    exports.ɵ0 = ɵ0;
    exports.ɵ1 = ɵ1;
    exports.ɵ2 = ɵ2;
    exports.ɵ3 = ɵ3;
    exports.ɵ4 = ɵ4;
    exports.ɵ5 = ɵ5;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-mat-errors.umd.js.map
